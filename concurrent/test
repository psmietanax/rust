use std::cell::{Cell, UnsafeCell};
use std::collections::LinkedList;
use std::hint::spin_loop;
use std::mem::MaybeUninit;
use std::sync::{Arc, Condvar, Mutex};
use std::sync::atomic::{AtomicUsize, Ordering};



struct BlockingQueue<V> {
    data: Arc<SharedData<V>>
}

struct SharedData<V> {
    guard: Mutex<LinkedList<V>>,
    cond: Condvar,
    capacity: usize
}

impl <V> BlockingQueue<V> {
    fn new(capacity: usize) -> Self {
        BlockingQueue {
            data: Arc::new(SharedData {
                guard: Mutex::new(LinkedList::new()),
                cond: Condvar::new(),
                capacity
            })
        }
    }
    // blocking
    fn put(&self, v: V) {
        let mut linkedlist = self.data.guard.lock().unwrap();
        while linkedlist.len() == self.data.capacity {
            linkedlist = self.data.cond.wait(linkedlist).unwrap();
        }
        linkedlist.push_front(v);
        self.data.cond.notify_all();
    }
    fn take(&self) -> V {
        let mut linkedlist = self.data.guard.lock().unwrap();
        while linkedlist.len() == 0 {
            linkedlist = self.data.cond.wait(linkedlist).unwrap();
        }
        let result = linkedlist.pop_back().unwrap();
        self.data.cond.notify_all();
        result
    }
}

impl <V> Clone for BlockingQueue<V> {
    fn clone(&self) -> Self {
        BlockingQueue {
            data: Arc::clone(&self.data)
        }
    }
}

//--

struct RingBufferData<T> {
    data: UnsafeCell<Vec<Option<T>>>
}

impl <T> RingBufferData<T> {
    fn new(capacity: usize) -> Self {
        let mut vec: Vec<Option<T>> = Vec::with_capacity(capacity);
        vec.resize_with(capacity, || None);

        RingBufferData {
            data: UnsafeCell::new(vec)
        }
    }
    unsafe fn offer(&self, idx: usize, elem: T) {
        let mut vec = &mut *self.data.get();
        vec[idx] = Some(elem);
    }
    unsafe fn take(&self, idx: usize) -> Option<T> {
        let mut vec = &mut *self.data.get();
        vec[idx].take()
    }
    unsafe fn exists(&self, idx: usize) -> bool {
        let vec = &*self.data.get();
        vec[idx].is_some()
    }
}

pub struct RingBuffer<T> {
    data: Arc<RingBufferData<T>>,
    head_seq: Arc<AtomicUsize>,
    tail_seq: Arc<AtomicUsize>,
    size: Arc<AtomicUsize>,
    capacity: Arc<usize>
}

unsafe impl <T> Send for RingBuffer<T> { }

impl <T> RingBuffer<T> {
    pub fn new(capacity: usize) -> Self {
        RingBuffer {
            data: Arc::new(RingBufferData::new(capacity)),
            head_seq: Arc::new(AtomicUsize::new(0)),
            tail_seq: Arc::new(AtomicUsize::new(0)),
            size: Arc::new(AtomicUsize::new(0)),
            capacity: Arc::new(capacity)
        }
    }
    pub fn size(&self) -> usize {
        self.size.load(Ordering::Acquire)
    }
    /*pub fn push(&self, elem: T) {
        unsafe {
            loop {
                // todo: relaxed ?
                let idx = self.head_seq.load(Ordering::Acquire);
                if !self.data.exists(idx) {
                    if self.head_seq.compare_exchange(idx, (idx + 1) % *self.capacity, Ordering::Release, Ordering::Relaxed).is_ok() {
                        self.data.offer(idx, elem);
                        break;
                    }
                }
            }
        }
    }*/
    /*pub fn pop(&self) -> Option<T> {
        unsafe {
            loop {
                let idx = self.tail_seq.load(Ordering::Acquire);
                if self.data.exists(idx) {
                    if self.tail_seq.compare_exchange(idx, (idx + 1) % *self.capacity, Ordering::Release, Ordering::Relaxed).is_ok() {
                        return self.data.take(idx);
                    }
                }
            }
        }
    }*/
    pub fn push(&self, elem: T) {
        unsafe {
            loop {
                let head = self.head_seq.load(Ordering::Acquire);
                let tail = self.tail_seq.load(Ordering::Acquire);

                if head != tail
                    || !self.data.exists(head) {

                    if self.head_seq.compare_exchange(head, (head + 1) % *self.capacity, Ordering::Release, Ordering::Relaxed).is_ok() {
                        self.data.offer(head, elem);
                        break;
                    }
                }
                spin_loop();
            }
        }
    }
    pub fn pop(&self) -> Option<T> {
        unsafe {
            loop {
                let idx = self.tail_seq.load(Ordering::Acquire);
                if self.data.exists(idx) {
                    if self.tail_seq.compare_exchange(idx, (idx + 1) % *self.capacity, Ordering::Release, Ordering::Relaxed).is_ok() {
                        return self.data.take(idx);
                    }
                }
                spin_loop();
            }
        }
    }
}

impl <T> Clone for RingBuffer<T> {
    fn clone(&self) -> Self {
        RingBuffer {
            data: Arc::clone(&self.data),
            head_seq: Arc::clone(&self.head_seq),
            tail_seq: Arc::clone(&self.tail_seq),
            size: Arc::clone(&self.size),
            capacity: Arc::clone(&self.capacity),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::sync::mpsc::channel;
    use std::thread;
    use std::time::Duration;
    use actix_web::http::header::q;
    use futures::SinkExt;
    use tokio::time::Instant;
    use super::*;

    //#[test]
    fn test() {
        let rb = RingBuffer::new(10000);
        let mut result = Vec::new();
        for i in 0..100 {
            let rb = rb.clone();
            result.push(thread::spawn(move || {
                for j in 0..100 {
                    rb.push(i*100 + j);
                }
            }));
        }

        result.into_iter().for_each(|jh| { jh.join(); });

        println!("{:?}", rb.pop());

        unsafe {
            println!("{:?}", &*rb.data.data.get());
        }
    }

    #[test]
    fn test_rb() {
        let mut timings = Vec::with_capacity(10);

        for _ in 1..10 {
            let queue = RingBuffer::new(100_000);
            let q2 = queue.clone();

            let start = Instant::now();
            thread::spawn(move || {
                for i in 1..1_000_000 {
                    q2.push(i);
                }
            });

            let mut sum: i128 = 0;
            loop {
                if let Some(res) = queue.pop() {
                    sum += res;
                    if res == 999_999 {
                        break;
                    }
                }
            }

            timings.push(start.elapsed().as_millis())
        }
        timings.sort();

        println!("rb: {:?}", timings);
    }

    #[test]
    fn test_mpsc() {
        let mut timings = Vec::with_capacity(10);

        for _ in 1..10 {
            let (ws, rs) = channel();

            let start = Instant::now();
            thread::spawn(move || {
                for i in 1..1_000_000 {
                    ws.send(i);
                }
            });

            let mut sum: i128 = 0;
            loop {
                let res = rs.recv();
                if res.is_err() {
                    break;
                }
                sum += res.unwrap();
            }

            timings.push(start.elapsed().as_millis())
        }
        timings.sort();

        println!("mpsc: {:?}", timings);
    }

    //#[test]
    fn test_blocking_queue() {
        let mut timings = Vec::with_capacity(10);

        for _ in 1..10 {
            let queue = BlockingQueue::new(100_000);
            let q2 = queue.clone();

            let start = Instant::now();
            thread::spawn(move || {
                for i in 1..1_000_000 {
                    q2.put(i);
                }
            });

            let mut sum: i128 = 0;
            loop {
                let res = queue.take();
                sum += res;
                if res == 999_999 {
                    break;
                }
            }

            timings.push(start.elapsed().as_millis())
        }
        timings.sort();

        println!("blocking queue: {:?}", timings);
    }

    //#[test]
    fn test_rtrb() {
        let mut timings = Vec::with_capacity(10);

        for _ in 1..10 {
            let (mut producer, mut consumer) = rtrb::RingBuffer::new(100_000);

            let start = Instant::now();
            thread::spawn(move || {
                for i in 1..1_000_000 {
                    producer.push(i);
                }
            });

            let mut sum: i128 = 0;
            let mut i = 0;
            while i < 999_999 {
                let res = consumer.pop();
                if res.is_ok() {
                    sum += res.unwrap();
                    i += 1;
                }
            }
            timings.push(start.elapsed().as_millis())
        }
        timings.sort();

        println!("rtrb: {:?}", timings);
    }
}
